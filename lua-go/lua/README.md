## Lua about

### luac 二进制分析

#### 生成二进制

```shell
luac xxx.lua -o binary.out
xxd binary.out
# ==========> byte
00000000: 1b4c 7561 5300 1993 0d0a 1a0a 0408 0408  .LuaS...........
00000010: 0878 5600 0000 0000 0000 0000 0000 2877  .xV...........(w
00000020: 4001|1240 7372 632f 3031 2d70 7269 6e74  @..@src/01-print
00000030: 2e6c 7561 0000 0000 0000 0000 0001 0206  .lua............
00000040: 0000 0006 0040 0041 4000 0024 4000 012c  .....@.A@..$@..,
00000050: 0000 0008 0000 8126 0080 0003 0000 0004  .......&........
00000060: 0670 7269 6e74 040c 6865 6c6c 6f20 776f  .print..hello wo
00000070: 726c 6404 0466 6f6f 0100 0000 0100 0100  rld..foo........
00000080: 0000 0003 0000 0005 0000 0000 0002 0300  ................
00000090: 0000 2c00 0000 0800 0080 2600 8000 0100  ..,.......&.....
000000a0: 0000 0404 6261 7201 0000 0000 0001 0000  ....bar.........
000000b0: 0000 0400 0000 0400 0000 0000 0201 0000  ................
000000c0: 0026 0080 0000 0000 0000 0000 0000 0000  .&..............
000000d0: 0001 0000 0004 0000 0000 0000 0000 0000  ................
000000e0: 0003 0000 0004 0000 0004 0000 0005 0000  ................
000000f0: 0000 0000 0001 0000 0005 5f45 4e56 0600  .........._ENV..
00000100: 0000 0100 0000 0100 0000 0100 0000 0500  ................
00000110: 0000 0300 0000 0500 0000 0000 0000 0100  ................
00000120: 0000 055f 454e 56                        ..._ENV
# <========== byte
```

#### 二进制组成分析：

##### 1. 签名

前四个字节为签名：（1b4c 7561）。分别为ESC、L、u、a的 ASCII 码。

##### 2. 版本号

签名之后的一个字节为 Lua版本号

主要由 Major Version + Minor Version + Release Version构成

Lua 的版本号由 Major + Minor Version计算得出。

举例：`0x53 = 5 * 16 + 3`

##### 3. 格式号

格式号如果与虚拟机格式号不匹配，则拒绝加载文件。

#### 4. LUAC_DATA

格式号后八位字节，为 Lua 中的LUAC_DATA。前两个字节 0x1993 为 Lua 发布年份。后四个字节为：回车、换行、替换、换行。

##### 5. 整数和 Lua 虚拟机指令宽度

后面五个字节，用来记录 cint、size_t、Lua 虚拟机指令、Lua整数、Lua浮点数五中数据类型在二进制 chunk 中占用的字节数。

##### 6. LUAC_INT

接下来 n （8） 个字节，存放 Lua 整数值 0x5678。主要是为了用来校验二进制文件大小端是否与本机匹配。如果不匹配则拒绝加载。

##### 7. LUAC_NUM

接下来的n个字节存放浮点370.5。主要用来检验二进制 chunk 的浮点格式是否为 IEEE 754浮点。

##### 8. 源文件名

主要记录 长度 + 1 （0x12） + 字符 ASCII 存储。

e.g: '@' => 0x64

其中 @ 开头代表这个 chunk 为 Lua 源文件编译来的。如果没有 @ 则代表这个二进制 chunk 为从程序字符串编译来的。

##### 9. 起止行号

起止行号是两个 cint 整形。主函数的起止行号都为 0。

##### 10. 固定参数个数

起止行号之后的一个字节，记录了函数固定参数个数。这里的固定参数，是相对变成参数而言的（Vararg）。

主函数无定长参数

##### 11. 是否为Vararg函数

判断是否有变长参数：0x01是，0x00否

主函数是 Vararg 函数，为 0x01

##### 12. 寄存器数量

记录是否为 Vararg 函数后面的一个字节为寄存器数量记录

##### 13. 指令表

函数基本信息以后为指令表，每条指令为 4byte。

##### 14. 常量表

指令表以后为常量表，常量表存储 Lua 中存在的字面量。每种常量由1byte tag开头，用来表示之后存储的为什么类型常量。

##### Upvalue 表

每个元素占用两个字节，用来存储信息。

##### 子函数原型表

##### 行号表

cint存储，行号表中行号和指令表的指令对应，分别记录指令在源代码中对应的行号。

##### 局部变量表

用来记录局部变量名，每个元素都包含变量名和起止指令索引。

##### Upvalue 名列表

列表中内容为Upvalue在源代码中的名字。